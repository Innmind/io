{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>This package provides a declarative way to consume streams and sockets.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require innmind/io\n</code></pre>"},{"location":"frames/","title":"Frames","text":"<p>A <code>Frame</code> is the declaration of the data you want to read.</p> <p>This is an immutable structure that you can compose any way you like.</p> <p>The declarative approach allows you to split the responsibility between declaring the shape of data you expect and the actual read operation.</p>"},{"location":"frames/#chunk","title":"<code>::chunk()</code>","text":"<p>This defines a string of a specified length.</p> <pre><code>use Innmind\\IO\\Frame;\n\n$chunk = Frame::chunk(512)-&gt;strict();\n// or\n$chunk = Frame::chunk(512)-&gt;loose();\n</code></pre> <ul> <li><code>-&gt;strict()</code> means that if the read data is not of the specified length it will fail</li> <li><code>-&gt;loose()</code> means that you allow the read data to be shorter than the specified length</li> </ul>"},{"location":"frames/#line","title":"<code>::line()</code>","text":"<p>This defines a string ending with <code>\\n</code>.</p> <pre><code>use Innmind\\IO\\Frame;\n\n$line = Frame::line();\n</code></pre>"},{"location":"frames/#sequence","title":"<code>::sequence()</code>","text":"<p>This defines a lazy <code>Sequence</code> of other frames.</p> <pre><code>use Innmind\\IO\\Frame;\n\n$lines = Frame::sequence(Frame::line());\n</code></pre> Note <p>Since the <code>Sequence</code> is lazy the error handling as to be done for each value.</p> <pre><code>use Innmind\\Immutable\\{\n    Sequence,\n    Str,\n    Attempt,\n};\n\n$lines = $lines-&gt;map(static fn(Sequence $lines) =&gt; $lines-&gt;map(\n    static fn(Attempt $line): Str $line-&gt;unwrap(),\n));\n</code></pre> <p>Here we throw an exception by calling <code>-&gt;unwrap()</code> is one of the lines failed to be read.</p>"},{"location":"frames/#compose","title":"<code>::compose()</code>","text":"<p>This allows to combine multiple frames together.</p> <pre><code>use Innmind\\IO\\Frame;\nuse Innmind\\Immutable\\Str;\n\n$request = Frame::compose(\n    static fn(Str $first, Str $second) =&gt; new HttpRequest($first, $second),\n    Frame::line(),\n    Frame::line(),\n);\n</code></pre> <p>Here it will read 2 lines and create an imaginary <code>HttpRequest</code> with them.</p> <p>Each new frame passed as argument will add an argument to the callable.</p>"},{"location":"frames/#buffer","title":"<code>::buffer()</code>","text":"<p>This is useful when you have a strict protocol where you know the length to read. This will read the whole length once and keep it in memory. This avoids watching the stream/socket too much.</p> <pre><code>use Innmind\\IO\\Frame;\n\n$frame = Frame::buffer(\n    100,\n    Frame::compose(\n        static fn(Str $a, Str $b, Str $c) =&gt; [$a, $b, $c],\n        Frame::chunk(20)-&gt;strict(),\n        Frame::chunk(20)-&gt;strict(),\n        Frame::chunk(60)-&gt;strict(),\n    ),\n);\n</code></pre> <p>This creates a frame containing 3 chunks. But instead of reading from the stream/socket 3 times it will do it only once.</p> <p>This is to improve performance, it doesn't have any behaviour impact.</p>"},{"location":"frames/#-filter","title":"<code>-&gt;filter()</code>","text":"<p>This method allows you to make sure the read data matches a condition. If the callable returns <code>false</code> it will fail the read.</p> <pre><code>use Innmind\\IO\\Frame;\nuse Innmind\\Immutable\\Str;\n\n$nonErroneousFrame = Frame::line()-&gt;filter(\n    static fn(Str $line) =&gt; !$line-&gt;contains('err:'),\n);\n</code></pre>"},{"location":"frames/#-map","title":"<code>-&gt;map()</code>","text":"<p>This method allows to transform the read data to any type you want.</p> <pre><code>use Innmind\\IO\\Frame;\nuse Innmind\\Immutable\\Str;\n\n$int = Frame::line()\n    -&gt;map(static fn(Str $line) =&gt; $line-&gt;trim()-&gt;toString())\n    -&gt;map(static fn(string $line) =&gt; (int) $line);\n</code></pre>"},{"location":"frames/#-flatmap","title":"<code>-&gt;flatMap()</code>","text":"<p>This method allows to dynamically determine the next frame from a previous one.</p> <pre><code>use Innmind\\IO\\Frame;\nuse Innmind\\Immutable\\Str;\n\n$value = Frame::chunk(1)\n    -&gt;strict()\n    -&gt;map(static function(Str $chunk) {\n        /** @var int&lt;0, 255&gt; $octet */\n        [, $octet] = \\unpack('C', $chunk-&gt;toString());\n\n        return $octet;\n    })\n    -&gt;flatMap(static fn(int $size) =&gt; Frame::chunk($size)-&gt;strict());\n</code></pre> <p>Here we read a first chunk of known length that contains the size of the rest of the data to read.</p> Info <p>This is a common pattern used in binary protocols.</p>"},{"location":"sockets/","title":"Sockets","text":""},{"location":"sockets/#servers","title":"Servers","text":""},{"location":"sockets/#internet","title":"Internet","text":"<pre><code>use Innmind\\IO\\{\n    IO,\n    Sockets\\Internet\\Transport,\n};\nuse Innmind\\IP\\IP;\nuse Innmind\\Url\\Authority\\Port;\n\n$server = IO::fromAmbientAuthority()\n    -&gt;sockets()\n    -&gt;servers()\n    -&gt;internet(\n        Transport::tcp(),\n        IP::v4('0.0.0.0'),\n        Port::of(8080),\n    )\n    -&gt;unwrap();\n</code></pre> <p>This will open the port <code>8080</code> on the machine and listen tcp connections coming from inside or outside the machine.</p>"},{"location":"sockets/#unix","title":"Unix","text":"<pre><code>use Innmind\\IO\\{\n    IO,\n    Sockets\\Unix\\Address,\n};\nuse Innmind\\Url\\Path;\n\n$server = IO::fromAmbientAuthority()\n    -&gt;sockets()\n    -&gt;servers()\n    -&gt;unix(Address::of(\n        Path::of('/path/to/socket'),\n    ))\n    -&gt;unwrap();\n</code></pre> <p>This will create a <code>/path/to/socket.sock</code> socket.</p> <p>If the socket already exists, if your script crashed for example, then this code will fail. You can fix that by using <code>-&gt;takeOver()</code> instead.</p> <pre><code>use Innmind\\IO\\{\n    IO,\n    Sockets\\Unix\\Address,\n};\nuse Innmind\\Url\\Path;\n\n$server = IO::fromAmbientAuthority()\n    -&gt;sockets()\n    -&gt;servers()\n    -&gt;takeOver(Address::of(\n        Path::of('/path/to/socket'),\n    ))\n    -&gt;unwrap();\n</code></pre>"},{"location":"sockets/#-watch","title":"<code>-&gt;watch()</code>","text":"<pre><code>$server = $server-&gt;watch();\n</code></pre> <p>This makes sure the socket is ready before trying to accept a new connection.</p> <p>This is the default behaviour.</p>"},{"location":"sockets/#-timeoutafter","title":"<code>-&gt;timeoutAfter()</code>","text":"<pre><code>use Innmind\\TimeContinuum\\Period;\n\n$server = $server-&gt;timeoutAfter(Period::second(1));\n</code></pre> <p>Like <code>-&gt;watch()</code> it will wait for the socket to be ready before accepting a new connection, except that if no connection came within <code>1</code> second it will fail.</p>"},{"location":"sockets/#-accept","title":"<code>-&gt;accept()</code>","text":"<pre><code>$client = $server\n    -&gt;accept()\n    -&gt;unwrap();\n</code></pre> <p>This returns a new connection made to the server. See below on how to use this client.</p>"},{"location":"sockets/#-pool","title":"<code>-&gt;pool()</code>","text":"<p>This allows to watch for multiple servers at once.</p> <pre><code>$clients = $server1\n    -&gt;pool($server2)\n    -&gt;accept();\n</code></pre> <p><code>$clients</code> is a <code>Innmind\\Immutable\\Sequence&lt;Innmind\\IO\\Sockets\\Clients\\Client&gt;</code>.</p>"},{"location":"sockets/#clients","title":"Clients","text":""},{"location":"sockets/#internet_1","title":"Internet","text":"<pre><code>use Innmind\\IO\\{\n    IO,\n    Sockets\\Internet\\Transport,\n};\nuse Innmind\\Url\\Url;\n\n$client = IO::fromAmbientAuthority()\n    -&gt;sockets()\n    -&gt;clients()\n    -&gt;internet(\n        Transport::tcp(),\n        Url::of('http://example.com')-&gt;authority(),\n    )\n    -&gt;unwrap();\n</code></pre>"},{"location":"sockets/#unix_1","title":"Unix","text":"<pre><code>use Innmind\\IO\\{\n    IO,\n    Sockets\\Unix\\Address,\n};\nuse Innmind\\Url\\Path;\n\n$client = IO::fromAmbientAuthority()\n    -&gt;sockets()\n    -&gt;clients()\n    -&gt;unix(Address::of(\n        Path::of('/path/to/socket'),\n    ))\n    -&gt;unwrap();\n</code></pre>"},{"location":"sockets/#-toencoding","title":"<code>-&gt;toEncoding()</code>","text":"<pre><code>use Innmind\\Immutable\\Str;\n\n$client = $client-&gt;toEncoding(Str\\Encoding::acsii);\n</code></pre> <p>This change the encoding of strings read. By default it uses <code>Str\\Encoding::utf8</code>.</p>"},{"location":"sockets/#-watch_1","title":"<code>-&gt;watch()</code>","text":"<pre><code>$client = $client-&gt;watch();\n</code></pre> <p>This makes sure the socket being read is ready, meaning there's data to be read. And it will wait forever until the socket is ready.</p> <p>This is default behaviour.</p>"},{"location":"sockets/#-timeoutafter_1","title":"<code>-&gt;timeoutAfter()</code>","text":"<pre><code>use Innmind\\TimeContinuum\\Period;\n\n$client = $client-&gt;timeoutAfter(Period::second(1));\n</code></pre> <p>Like <code>-&gt;watch()</code> it will wait for the socket to be ready before being read, except that if it's not ready within <code>1</code> second it will fail the read operation.</p>"},{"location":"sockets/#-poll","title":"<code>-&gt;poll()</code>","text":"<p>This is a shortcut to <code>-&gt;timeoutAfter(Period::second(0))</code>. This means that if the socket is not ready right away when read it will fail.</p>"},{"location":"sockets/#-heartbeatwith","title":"<code>-&gt;heartbeatWith()</code>","text":"<pre><code>use Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n$client = $client-&gt;heartbeatWith(\n    static fn() =&gt; Sequence::of(Str::of('heartbeat')),\n);\n</code></pre> <p>When reading from the socket it will send the data provided by the callable through the socket. It does this when watching for the socket to be ready times out.</p> <p>This means you must use <code>-&gt;timeoutAfter()</code> to use this feature, otherwise it will never send the heartbeat message.</p> <p>When a heartbeat message is sent then the client will resume watching the socket.</p>"},{"location":"sockets/#-abortwhen","title":"<code>-&gt;abortWhen()</code>","text":"<p>This method should be used in tandem with <code>-&gt;heartbeatWith()</code>. The heartbeat mechanism essentially creates an infinite loop of watching the socket to be ready to be read.</p> <p>This method allows you to specify a condition to break this infinite loop.</p> <pre><code>$client = $client-&gt;abortWhen(\n    static fn(): bool =&gt; someCondition(),\n);\n</code></pre> <p>Usually the condition to use is a process signal (like <code>SIGINT</code>).</p>"},{"location":"sockets/#-frames","title":"<code>-&gt;frames()</code>","text":"<p>This is the main way to read data from sockets.</p> <pre><code>use Innmind\\IO\\Frame;\n\n$frames = $client-&gt;frames(Frame::line());\n</code></pre> <p>Then you can either read:</p> One frameMultiple frames <pre><code>$line = $frames\n    -&gt;one()\n    -&gt;unwrap();\n</code></pre> <p><code>$line</code> is an instance of <code>Innmind\\Immutable\\Str</code>. <code>-&gt;one()</code> returns an <code>Attempt</code> monad that we <code>-&gt;unwrap()</code> here, meaning that if it fails to read the frame then it will throw an exception.</p> <pre><code>$lines = $frames\n    -&gt;lazy()\n    -&gt;sequence();\n</code></pre> <p><code>$lines</code> is a <code>Innmind\\Immutable\\Sequence&lt;Innmind\\Immutable\\Str&gt;</code>.</p> <p>Since the sequence is lazy this means that you may read some lines and then an exception is thrown if it fails to read a line.</p> <p>See the Frames section to learn how to create frames.</p>"},{"location":"sockets/#-sink","title":"<code>-&gt;sink()</code>","text":"<pre><code>use Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n$successful = $client-&gt;sink(\n    Sequence::of(\n        Str::of('chunk 1'),\n        Str::of(\"new line \\n\"),\n        Str::of('chunk 2'),\n        Str::of('etc...'),\n    ),\n);\n</code></pre> <p>This will send each <code>Str</code> one after the other through the socket.</p> <p><code>$successful</code> is an <code>Attempt</code> monad. It will contain an error if it failed to send one the chunks.</p> <p>Since the data to send is expressed with a <code>Sequence</code>, you can use a lazy one to send data that may not fit in memory.</p>"},{"location":"sockets/#pair","title":"Pair","text":"<pre><code>[$a, $b] = IO::fromAmbientAuthority()\n    -&gt;sockets()\n    -&gt;pair()\n    -&gt;unwrap();\n</code></pre> <p>This creates a pair of socket clients link to one another. This is useful for inter process communication.</p>"},{"location":"streams/","title":"Streams","text":"<p>You can use streams by passing a <code>resource</code> to this package like so:</p> <pre><code>use Innmind\\IO\\IO;\n\n$stream = IO::fromAmbientAuthority()\n    -&gt;streams()\n    -&gt;acquire(\\STDIN);\n</code></pre>"},{"location":"streams/#read","title":"Read","text":"<pre><code>$read = $stream-&gt;read();\n</code></pre>"},{"location":"streams/#-nonblocking","title":"<code>-&gt;nonBlocking()</code>","text":"<pre><code>$read = $read-&gt;nonBlocking();\n</code></pre> <p>This will configure the stream to be non blocking when reading from it. This means that it will return as soon as possible with <code>string</code>s shorter than the expected size.</p>"},{"location":"streams/#-toencoding","title":"<code>-&gt;toEncoding()</code>","text":"<pre><code>use Innmind\\Immutable\\Str;\n\n$read = $read-&gt;toEncoding(Str\\Encoding::ascii);\n</code></pre> <p>This changes the encoding used in all <code>Str</code> values returned. By default it's <code>Str\\Encoding::utf8</code>.</p>"},{"location":"streams/#-watch","title":"<code>-&gt;watch()</code>","text":"<pre><code>$read = $read-&gt;watch();\n</code></pre> <p>This makes sure the stream being read is ready, meaning there's data to be read. And it will wait forever until the stream is ready.</p> <p>This is default behaviour.</p>"},{"location":"streams/#-timeoutafter","title":"<code>-&gt;timeoutAfter()</code>","text":"<pre><code>use Innmind\\TimeContinuum\\Period;\n\n$read = $read-&gt;timeoutAfter(Period::second(1));\n</code></pre> <p>Like <code>-&gt;watch()</code> it will wait for the stream to be ready before being read, except that if it's not ready within <code>1</code> second it will fail the read operation.</p>"},{"location":"streams/#-poll","title":"<code>-&gt;poll()</code>","text":"<p>This is a shortcut to <code>-&gt;timeoutAfter(Period::second(0))</code>. This means that if the stream is not ready right away when read it will fail.</p>"},{"location":"streams/#-pool","title":"<code>-&gt;pool()</code>","text":"<pre><code>$pool = $stream1\n    -&gt;pool('a')\n    -&gt;with('b', $stream2);\n</code></pre> <p>This method allows to combine multiple streams that will be read together.</p> <p>Here <code>a</code> and <code>b</code> are ids used to reference from which stream the read data comes from. You can use any type you want.</p> <p>Then you can read available chunks from this pool like this:</p> <pre><code>use Innmind\\Immutable\\Pair;\n\n$pool\n    -&gt;chunks()\n    -&gt;foreach(static fn(Pair $chunk) =&gt; match ($chunk-&gt;key()) {\n        'a' =&gt; doSomethingWithStream1($chunk-&gt;value()),\n        'b' =&gt; doSomethingWithStream2($chunk-&gt;value()),\n    });\n</code></pre>"},{"location":"streams/#-frames","title":"<code>-&gt;frames()</code>","text":"<p>This is the main way to read data from streams.</p> <pre><code>use Innmind\\IO\\Frame;\n\n$frames = $read-&gt;frames(Frame::line());\n</code></pre> <p>Then you can either read:</p> One frameMultiple frames <pre><code>$line = $frames\n    -&gt;one()\n    -&gt;unwrap();\n</code></pre> <p><code>$line</code> is an instance of <code>Innmind\\Immutable\\Str</code>. <code>-&gt;one()</code> returns an <code>Attempt</code> monad that we <code>-&gt;unwrap()</code> here, meaning that if it fails to read the frame then it will throw an exception.</p> <pre><code>$lines = $frames\n    -&gt;lazy()\n    -&gt;sequence();\n</code></pre> <p><code>$lines</code> is a <code>Innmind\\Immutable\\Sequence&lt;Innmind\\Immutable\\Str&gt;</code>.</p> <p>Since the sequence is lazy this means that you may read some lines and then an exception is thrown if it fails to read a line.</p> <p>See the Frames section to learn how to create frames.</p>"},{"location":"streams/#write","title":"Write","text":"<pre><code>$write = $stream-&gt;write();\n</code></pre>"},{"location":"streams/#-sink","title":"<code>-&gt;sink()</code>","text":"<pre><code>use Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n$successful = $write-&gt;sink(\n    Sequence::of(\n        Str::of('chunk 1'),\n        Str::of(\"new line \\n\"),\n        Str::of('chunk 2'),\n        Str::of('etc...'),\n    ),\n);\n</code></pre> <p>This will write each <code>Str</code> one after the other to the stream.</p> <p><code>$successful</code> is an <code>Attempt</code> monad. It will contain an error if it failed to write one the chunks.</p> <p>Since the data to write is expressed with a <code>Sequence</code>, you can use a lazy one to write data that may not fit in memory.</p>"},{"location":"files/read/","title":"Read files","text":""},{"location":"files/read/#by-chunks","title":"By chunks","text":"<pre><code>use Innmind\\IO\\IO;\nuse Innmind\\Url\\Path;\n\n$chunks = IO::fromAmbientAuthority()\n    -&gt;files()\n    -&gt;read(Path::of('/path/to/file.ext'))\n    -&gt;chunks(8192);\n</code></pre> <p>This will produce a lazy <code>Sequence</code> containing <code>Str</code> objects with each value with a length of at most <code>8192</code>.</p>"},{"location":"files/read/#by-lines","title":"By lines","text":"<pre><code>use Innmind\\IO\\IO;\nuse Innmind\\Url\\Path;\n\n$chunks = IO::fromAmbientAuthority()\n    -&gt;files()\n    -&gt;read(Path::of('/path/to/file.ext'))\n    -&gt;lines();\n</code></pre> <p>This will produce a lazy <code>Sequence</code> containing <code>Str</code> objects. Each line ends with <code>\\n</code>, except the last one.</p>"},{"location":"files/read/#with-a-specific-encoding","title":"With a specific encoding","text":"<p>By default when reading a file the <code>Str</code> produced uses the <code>Str\\Encoding::utf8</code>. You can change that like this:</p> <pre><code>use Innmind\\IO\\IO;\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Str;\n\n$chunks = IO::fromAmbientAuthority()\n    -&gt;files()\n    -&gt;read(Path::of('/path/to/file.ext'))\n    -&gt;toEncoding(Str\\Encoding::ascii)\n    -&gt;lines();\n</code></pre>"},{"location":"files/temporary/","title":"Temporary","text":"<pre><code>use Innmind\\IO\\IO;\nuse Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n$temporary = IO::fromAmbientAuthority()\n    -&gt;files()\n    -&gt;temporary(Sequence::of(\n        Str::of('chunk 1'),\n        Str::of(\"new line \\n\"),\n        Str::of('chunk 2'),\n        Str::of('etc...'),\n    ))\n    -&gt;unwrap();\n</code></pre> <p>This creates a temporary file without having to think about where to store it.</p> <p>You can then use it in 2 ways:</p> Like a normal fileChunk by chunk <pre><code>$temporary\n    -&gt;read()\n    -&gt;chunks(8192);\n// or\n$temporary\n    -&gt;read()\n    -&gt;lines();\n</code></pre> <pre><code>$pull = $temporary-&gt;pull();\n\ndo {\n    $chunk = $pull\n        -&gt;chunk(512)\n        -&gt;unwrap();\n    doSomething($chunk);\n} while (!$chunk-&gt;empty());\n</code></pre> <p>The call to <code>-&gt;chunk()</code> is stateful as it remembers the position in the file. This means that you can only read forward, and only once.</p> <p>Once you're down working with the file you can close it like this:</p> <pre><code>$temporary-&gt;close()-&gt;unwrap();\n</code></pre>"},{"location":"files/temporary/#incremental-file-creation","title":"Incremental file creation","text":"<p>When bridging this library with a more imperative API, using the <code>Sequence</code> to declare the chunks of the temporary file may not be possible.</p> Info <p>This is the case with the <code>curl</code> extension for example.</p> <p>In this case you need to use the push strategy:</p> <pre><code>use Innmind\\IO\\IO;\nuse Innmind\\Immutable\\{\n    Sequence,\n    Str,\n    SideEffect,\n};\n\n$temporary = IO::fromAmbientAuthority()\n    -&gt;files()\n    -&gt;temporary(Sequence::of())\n    -&gt;unwrap();\n\nsomeImperativeAPI(\n    static fn(Str $chunk): SideEffect =&gt; $temporary\n        -&gt;push()\n        -&gt;chunk($chunk)\n        -&gt;unwrap(),\n);\n</code></pre>"},{"location":"files/write/","title":"Write to files","text":"<pre><code>use Innmind\\IO\\IO;\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n$successful = IO::fromAmbientAuthority()\n    -&gt;files()\n    -&gt;write(Path::of('/path/to/file.ext'))\n    -&gt;sink(Sequence::of(\n        Str::of('chunk 1'),\n        Str::of(\"new line \\n\"),\n        Str::of('chunk 2'),\n        Str::of('etc...'),\n    ));\n</code></pre> <p><code>$successful</code> is an instance of <code>Attempt&lt;SideEffect&gt;</code>.</p> <p>Since the data to write is expressed with a <code>Sequence</code>, you can use a lazy one to create files that may not fit in memory.</p>"},{"location":"use-cases/files/chunks/","title":"Reading from a file by chunks","text":"<pre><code>use Innmind\\IO\\IO;\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Str;\n\n$chunks = IO::fromAmbienAuthority()\n    -&gt;files()\n    -&gt;read(Path::of('/some/file.ext'))\n    -&gt;toEncoding(Str\\Encoding::ascii)\n    -&gt;chunks(8192); // max length of each chunk\n</code></pre> <p>The <code>$chunks</code> variable is a <code>Innmind\\Innmutable\\Sequence</code> containing <code>Innmind\\Immutable\\Str</code> values, where each value is of a maximum length of <code>8192</code> bytes.</p>"},{"location":"use-cases/files/lines/","title":"Reading from a file by lines","text":"<pre><code>use Innmind\\IO\\IO;\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Str;\n\n$lines = IO::fromAmbienAuthority()\n    -&gt;files()\n    -&gt;read(Path::of('/some/file.ext'))\n    -&gt;toEncoding(Str\\Encoding::ascii)\n    -&gt;lines();\n</code></pre> <p>This is the same as reading by chunks (described above) except that the delimiter is the end of line character <code>\\n</code>.</p>"},{"location":"use-cases/socket/heartbeat/","title":"Reading from a socket with a periodic heartbeat","text":"<pre><code>use Innmind\\IO\\{\n    IO,\n    Frame,\n    Sockets\\Internet\\Transport,\n};\nuse Innmind\\TimeContinuum\\Period;\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\{\n    Str,\n    Sequence,\n};\n\n$status = IO::fromAmbienAuthority()\n    -&gt;sockets()\n    -&gt;clients()\n    -&gt;internet(\n        Transport::tcp(),\n        Url::of('https://github.com')-&gt;authority(),\n    )\n    -&gt;map(\n        static fn($socket) =&gt; $socket\n            -&gt;timeoutAfter(Period::second(1))\n            -&gt;heartbeatWith(static fn() =&gt; Sequence::of(Str::of('heartbeat')))\n            -&gt;frames(Frame::line()),\n    )\n    -&gt;flatMap(static fn($frames) =&gt; $frames-&gt;one())\n    -&gt;unwrap()\n    -&gt;toString();\n</code></pre> <p>This is the same thing as the previous example except that it will send <code>heartbeat</code> through the socket every second until the server send a line.</p> <p>You can call <code>-&gt;abortWhen()</code> after <code>-&gt;heartbeatWith()</code> to determine when to stop sending a heartbeat.</p>"},{"location":"use-cases/socket/read/","title":"Reading from a socket","text":"<pre><code>use Innmind\\IO\\{\n    IO,\n    Frame,\n    Sockets\\Internet\\Transport,\n};\nuse Innmind\\TimeContinuum\\Period;\nuse Innmind\\Url\\Url;\n\n$status = IO::fromAmbienAuthority()\n    -&gt;sockets()\n    -&gt;clients()\n    -&gt;internet(\n        Transport::tcp(),\n        Url::of('https://github.com')-&gt;authority(),\n    )\n    -&gt;map(\n        static fn($socket) =&gt; $socket\n            -&gt;timeoutAfter(Period::second(1))\n            -&gt;frames(Frame::line()),\n    )\n    -&gt;flatMap(static fn($frames) =&gt; $frames-&gt;one())\n    -&gt;unwrap()\n    -&gt;toString();\n</code></pre> <p>This example opens a <code>tcp</code> connection to <code>github.com</code> and will wait <code>1</code> second for the server to respond. If the server responds it will read the first line sent and assign it in <code>$status</code> (it should be <code>HTTP/2 200</code>).</p> <p>If the server doesn't respond within the timeout or an entire line is not sent then this will throw an exception (when <code>-&gt;unwrap()</code> is called).</p> <p>If you want to wait forever for the server to respond you can replace <code>-&gt;timeoutAfter()</code> by <code>-&gt;watch()</code>.</p>"}]}